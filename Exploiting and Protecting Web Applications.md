# Command Injection
Any type of program which is trying to access some kind of access based on some constraints can be vulnerable to code injection.

### SQL Injection
Attacker can perform data theft, he can corrupt data, insert malicious data. 

__Best practices__ 
* Blacklisting : remove quotes, etc from the input string by user. But this method might miss some dangerous character put in the input. So this approach will not work anyways on most of the attacks. 
* Whitelist : only allow some certain character through. By making use of regex. 
* Formatting strings 
* Making use of Prepare statements and bind variables ensure input is data. 
* Limiting Privileges : Applications might be logged in as root, if it needs to just read from DB. Use the appropriate login users for different applications. 
* Encrypt Data : Key should not be stored in same DB 
* Input data validation: needs to be done at every step not just when user’s input. All Paramus can be potentially dangerous, 

_LDAP_ Lightweight Dir Access protocol

_Blind SQL Injection Attack_ : Done to determine the schema of the application. By default in case of any error, the apps are designed to throw as much info as possible out, to help debug the issue. But this info if leaked to attacker is dangerous. 

### XSS Cross site scripting
Attack where attacker is able to get his script run on the web-app. 

* __Reflected__ : script injected into a request and returned immediately in response. (Like query parameter example)
Attacker can use this to steal cookies. Here the attacker can also change the injected script to be a java script which 
doesn’t even open up a new web page etc, it just uploads the cookie data to the attackers HTML page somewhere. 
It’s man-in-middle attack. 
* __Stored__ : script delivered to victim some time after being injected. Here the attacker tries got inject something in the application DB etc, in a manner making it repeatable for anyone who in future makes use of the application. 

DOM(document object model) based : script injected doesn’t need to get echoed through server. 
If you can access part of the DOM as input which causes problem. 
In this case Server may never see attack string. 
Server side filtering is totally circumvented.
Sanitization or escaping done in JavaScript is visible to attackers. 
Avoiding client side document rewriting/redirection of other sensitive actions using client side data 

_Preventing XSS_
* Input validation
* Output Sanitization /escaping check string as they are being inserted into HTML documents. All special chars should be 
treated as data by properly escaping it while output the read inputs. 
* Whitelisting data in case of URL attributes otherwise the user can provide some data as input instead to escaping etc, 
because the attacker can provide a URL and put up his code there from where he can then attack. Same goes for style attributes. 
* __Web Application Firewall__ 
Handles requests before they get to the web application to prevent XSS attack or SQL injection attack. 
Helps in tracking attacker as well. 
* Tools : There are packages etc which can scan your code and try to figure out different type of SQL injection attacks or 
XSS attacks. 
* Penetration testing scanners: tools are only able to capture about 10-50% not possible attacks. 

### XSRF cross site request forgery
Legitimate Http request is indistinguishable from attackers request. 
Client authenticates and server gives a cookie to help with authentication. In this attack, attacker makes use of 
the cookie or in the current session to fool the server. 

__Prevention__ 
* Action token way 1. making user make some action etc to authenticate it’s coming form the user itself and not from some script. 
* Action token way 2: generating action tokens. Some form of signature. Which is signed by a key known just to the bank/ 

### XSSI: cross site script inclusion 
Hacker is able to trick the browser to run his malicious script instead of the original script to be run by the site. 
Prevention : action tokens again. Requiring by some form of action from the user can prevent this. 

### Cache Injection
Users browsers keep cache of the last seen pages, before they try and get latest version of file. But cache can get poisoned, 
and can be tricked to be man in middle attack. Ex. The attacker can replace the jQuery kept in the cache by browser with 
his queries. Thus he can use the connections for his benefit.

Prevention Making use of HTTPS instead of HTTP. 

## HTML 5 :
It’s new HTML standard. Where they added new features, which also addressed some security issues.
* Canvas tag : area where you can do 2D-3D data rendering. 
* Video / Audio elements 
* Local storage : small amt of info can be saved in here
* Tags for content specific elements 
* Form control like date, time. 
* Widgets (libs kind of things) which are now slowly becoming standards. 

For 3D images to be shown in canvas, graphic card needs to now run code run from websites, which can be a potential threat. 
Now the graphics card are accessible to the webpage, thus attacker doesn't need to actually create a process in the victims 
computer to have access to its resources. Just getting him to your web browser is enough. 
__Memory stealing__ Malicious pages are able to run and get access to clients graphics card. They can they copy clients 
screen into their machine. 

Cycle stealing 


### Cross Origin resources sharing 
By default, one website cannot read content from different sites. 
If server allows it HTML 5 will allow it. 
HTML 5 includes CORS support for Img and video elements.
Now sites can read each other’s data and have more control over how to authorize it, if they want to share cookies or not. 

__CORS tips__
* Don’t use Access-control-allow-origin from a given domain. 
* Whitelist certain trusted domains. 
* Origin header can be spoofed so it should be authenticated and think about how/what data should be sent out to the 
client upon request. 

### HTTPS
__Network attacker__ he controls the router, etc can modify the packets, listen, inject. 

* Certificate authority signs Bobs Public key with its secret Key. And Alice as a client can verify Bobs public key by 
being able to decrypt it with CA’s public key. Wildcard certificates are also allowed. * will work for anything but a ‘.’
* SSL provides one sided authentication.  
* Used to establish connection between server and browser. And a secure key. 

__Web-proxy__ used to route the different requests to the appropriate location. Before client send hello and browser send in a connect domain-name to the server. 

__Virtual hosting__
Hosting services have multiple domains on same IP. So now if a get request comes to a server using the host header the 
web server knows which page to sends back to the client. Problem : server doesn’t know which domain related certification 
should be sent out to the client. 
__SNI__(Server name identification) This way the server knows which domain the client is interested in. 
IE6 doesnt support SNI 

Why not encrypt all HTTP traffic ? 
* Crypto process slows down web servers. - no longer its a valid response 
* After SSL is enabled, ISP cannot cache content. Because all content is encrypted, it would not make any use for the ISP. 

Setup a secure connection and then hovering over the lock shows in detail how the connection was established. 
Details about the Certificates, what type of key was used to establish the connection. 

__Extended validation certificates__ A human is involved in the issuing of the certificate to ensure no kind of 
phishing/spoofing attacks can take place. 

Attacker can remove the s from https and then be able to steal the login data. 

Problems with HTTPS 

* Http -> https upgrade. BY default get requests are routed to http version of the site. And google would also return the 
stripped version. Servers nowadays make sure the users are redirected to the https pages for them before opening the 
login pages for them. 
__Attack__ on it : Attacker can was able to become man in the middle and became the end-point for the Https upgrade. He can 
inject the lock icon thingy on the wrong side of the address bar. 
Prevention : Strict Transport security the first time the browser connects to the bank. The bank replies with header that 
Don’t ever use http with me. So it ensures that connection must be over SSL. Problem with above: entire domain needs to be hosted over SSL. 

* Invalid Certificates getting issued : become vulnerable to man in the middle attack. The attacker will become the point of 
contact for every conversation between user and the server. And because the attacker has the valid certificate there is 
no way for the victim to identify this. 
* * __Http pinning__ : bowsers know for each company which Certificate authorities can authorize their certificate. Another way trust the first use of a Certificate and on subsequent tries the browser know which CA issued the certificate for this site earlier and it should match. 
* * __Certificate Transparency : CA’s must advertise a log of all certificates 
* Mixed content : sites are served over SSL but some content on the site is still served over Http. 
* Peeking through SSL : Network traffic reveals length of HTTP packets AJAX rich pages have lots of interactions with the server These interactions expose specific internal state of the page. 
* RC4 stream cipher : has security problems. It doesnt hide the first few bits very well 

##### Cookies 
* Server can set the cookie for a sub domain not the parent domain. 
* Can set it to null : to determine validity for that session. 
* Past date : to indicate the cookie needs to be deleted . 
* Can be marked as secure => cookie should be sent to the server only over SSL . 
* Reading cookie on server : 
* Cookies do not have any integrity. So attacker can modify those cookies. 
* Solution cryptographic checksums to introduce data integrity on them. Decryption would require key from server. 


##### Session management
Sequence of request and response between user and server. They allow user to authenticate once and not needed to do that again.
Storing session tokens just in cookies make them vulnerable to cross site request forgery
If they are stored in URL, they would get leaked by the refer header, and whole world can figure it out by looking at the uRL 
Hidden form field : for long lived session it can become a problem. Because the moment the user moves out of the webpage the 
token is lost. best solution : combination of all 3

Logout process: allows user to close the session. And preventing others to access their credentials. 
Invalidate the session token on the browser and also at the server. 
Website usually forget to delete the session at the server. 

__Session Hijacking__
Waits for the user to login and then hijack their session token. 
Network attacker can very easily monitor the session token the moment sites move from SSL to HTTP. 

__Session fixation attacks__ : attacker generate a anonymous session token for site. And passes this token to victim. 
And now the user logs onto the site and thus authenticate the session token. Now when the attacker’s session token gets 
authenticated. 
Solution: whenever you move from non authenticate session to authenticated session, create a new session token. 
Thus attackers session token never got authenticate. 

Summary : always assume cookies are not trustworthy 
Session token need to be 
* Unpredictable 
* Resistant to theft 
* Always loggedout => session is invalidated on client and server 



#### Web application vulnerabilities
__Network attacker__ has much more access than usual people who attack from web via some random website owner etc..

__Malware attacker__ being able to install something on the website. So even more powerful than network attacker. 
Because then he has access to filesystem and web etc. 

__URL__ 
* Http: protocol 
* S->Secure 
* Host Name (Domain )
* Port : where to look and what software to look to to connect 
* Path: name of file or program on the receiving system 
* Query Params: 
* Fragment: on the page where to go.. 

Request can be a Get or a POST(contains data): 
* POST : possible side effect on the session 
Refer header: to track data and also determine what site recommended the website to this page. 
* Http response : 
* * Version .. status code response phrase 
* * Header 
* * Data 
* * Cookies : 
* Rendering content : 
It can come from different sources, graphic etc. Ads come from different places. 
Browser gets the content and then renders it. Basically a set of scripts are run by browser. 
Once data has been rendered.. then some actions/events control the next step. 
* DOM: Document Object Model 
Java script Object oriented interface to read write docs. 
While rendering, if coded incorrectly, instead of getting some non threatening data, might end up getting extra info from user. 
* __Firewall__ It’s able to provide some form of isolation for the data that can sent out to a remote server. 
* __Remote scripting__ Continuing communication between client and server. Clients browser keeps on polling the server on 
how can I change the page now.. 
* Component of isolation is a frame. Iframe : inline frame,which doesn’t have a border, just one entity. 
* There is a 1-1 mapping between OS and Web browser : 
* * System calls -> Document object Model 
* * Processes -> Frames 
* * Disk -> cookies 
* * DAC (Discretionary access control)-> Mandatory access control 
* Same origin policy : frames can access data from same origin. 
* * Origin = Protocol://host:port 
* * CanScript Check can also be added 
* * CanNavigate : cause the frame to be loaded again when a different frame is loaded 
* Data on page A even if its coming from some other domain X. Now if frame B is in same domain as A, B and A will be consider to be vulnerable from attacks from X. 
* Domain relaxation : Browser can relax this domain constraint to a suffix of its domain based on the need. 

__HTML5 Frame Sandboxing__ Strongly Isolated.. and different features can be weakened if needed.. 
* It will protect the page in a bit stronger way. 
* Plugins are disabled 
* Forms are disabled 
* Scripts are disabled - needs to be a static page.. 
* Links to other browsing contexts are disabled: cant have any hyperlinks.. 
* Links to other contexts are disabled 
* Unique Origin treatment: the content coming in from this page is treated as coming from Unique Origin => will not get treated the content is not traversal to the DOM or to read cookie info.. 

__Navigation of pages__
Content from one site interact with content from another. 
If any frame  is able to load any part of the frame. Then if there is a frame with login details, attacker will be able to 
copy this into his page… 
What policy to allow frame navigation : 
* * one frame can navigate sibling, 
* * One frame can change its child 

__Fragment identifier messaging__
One frame navigates another frame to a fragment of a different frame, then the frame doesnt get loaded. 
Because the loaded data is already present, and cache is used to get the frame data.. 
Not secure with regards to confidentiality, integrity and authentication. 

__Post message mechanism__ msg can be sent from one frame to the browser. It tells which frame this conversation needs to 
take place. This conversation can only happen for a specific origin. 
This might not be possible in all the bowsers as of now because this is a new concept. Then gadget is supposed to call 
back to fragment identifier messaging. 
Two way communication : Build on top of postMessage. Each time a call from iFrame in page is made, you also pass a reply function that is called with results of that method call,


__Client state__
Interaction between content on the browser and server. 
_Native client_ allowing browser to install something not he client machine to be able to interact with user. 
_Cookies_ store state of the users interaction. 
It’s a set of name value pairs. 
It contains domain details, has some security tags. Has an expiration date. For each next interaction with the bowser will contain the cookie details. (Saved at browser level and not laptop)

__Security policy__ third party tracking Content from only the site which has same origin. But then there might be multiple 
cookies for same origin and then browser might send all. 

__Secure cookies__ can only be sent over HTTPS. From browser to server must be sent over with encryption. 
Some of these cannot be used by Java script if set like that. Making them more secure

__Local storage__ more flexible way to store data. 
Key value pairs like cookie. But the data can be more complicated and can be used by Java script. Can be used for offline handling of data. Data is stored as a string 
Some browser also impediment SQL database.

__Security issues__
Seperate store per origin. 
Its not protected from the user. So server shouldn’t put in confidential things there. 
Java script would have access to it. Vulnerable to XSS
Integrity issue, rewriting or reading of data. 

Native Client: browser can have frame on page inside a sandbox and then 

__Static analysis validation__ Can be done on sites to ensure its not malicious. Its monitored while running to see what’s 
going on, and is killed in case anything malicious is done by it. 

__Clickjacking__ so something on the top hides what’s actually happening the background to the user. 

__Frame busting__ Sites check is they are not inside some other overlay page/frame. 












